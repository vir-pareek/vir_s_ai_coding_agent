{
  "problem_statement": "To ensure rebel communications are between humans, captcha difficulties have increased drastically. For each rebel to prove they are human and contact the base, they must solve the following puzzle:\nGiven a bitstring \nS\nS consisting of \n2\nN\n2N characters (each 0 or 1), sort it using the following operation at most \n10\nN\n10N times:\nPartition the indices \n[\n1\n,\n2\n,\n3\n,\n.\n.\n.\n,\n2\nN\n]\n[1,2,3,...,2N] into two sorted arrays \nA\nA and \nB\nB of equal length \nN\nN. Each index in \n1..2\nN\n1..2N must be assigned to either \nA\nA or \nB\nB.\nFor every \ni\n=\n1..\nN\ni=1..N, swap \nS\nA\ni\nS \nA \ni\n\u200b\n \n\u200b\n  and \nS\nB\ni\nS \nB \ni\n\u200b\n \n\u200b\n .\nIf sorting the bitstring in nondecreasing order is possible in at most \n10\nN\n10N operations, find any way of doing it. If it isn't possible, output \n\u2212\n1\n\u22121.\nConstraints\n1\n\u2264\nT\n\u2264\n80\n1\u2264T\u226480\n3\n\u2264\nN\n\u2264\n150\n3\u2264N\u2264150\n\u2223\nS\n\u2223\n=\n2\nN\n\u2223S\u2223=2N\nS\ni\n\u2208\n{\nS \ni\n\u200b\n \u2208{'0', '1'\n}\n}\nInput Format\nInput begins with an integer \nT\nT, the number of test cases. The first line of each case contains a single integer \nN\nN. The second line of each test case contains the bitstring \nS\n1..2\nN\nS \n1..2N\n\u200b\n .\nOutput Format\nFor the \ni\nith test case:\nIf sorting the bitstring in at most \n10\nN\n10N operations is possible:\nPrint \"Case #i: \" followed by a single integer \nM\nM no greater than \n10\nN\n10N, the number of operations to sort the bitstring.\nThen print \nM\nM pairs of lines (\n2\nM\n2M lines total). Each pair of line denotes an operation.\nThe first line of each operation should contain \nN\nN space-separated integers specifying the array \nA\nA.\nThe second line of each operation should contain \nN\nN space-separated integers specifying the array \nB\nB.\nIf sorting the bitstring in at most \n10\nN\n10N operations is impossible:\nPrint \"Case #i: -1\".\nSample Explanation\nIn the first sample case, \nN\n=\n3\nN=3 and the bitstring \nS\n=\nS= 101000 can be sorted by the following sequence of operations:\nOperation 1: swap indices \nA\n=\n[\n1\n,\n3\n,\n5\n]\nA=[1,3,5] with \nB\n=\n[\n2\n,\n4\n,\n6\n]\nB=[2,4,6]. Indices in \nA\nA are labeled with square brackets.\n[1]0[1]0[0]0 becomes 010100.\nOperation 2: swap indices \nA\n=\n[\n1\n,\n2\n,\n3\n]\nA=[1,2,3] with \nB\n=\n[\n4\n,\n5\n,\n6\n]\nB=[4,5,6].\n[0][1][0]100 becomes 100010.\nOperation 3: swap indices \nA\n=\n[\n1\n,\n3\n,\n4\n]\nA=[1,3,4] with \nB\n=\n[\n2\n,\n5\n,\n6\n]\nB=[2,5,6].\n[1]0[0][0]10 becomes 011000.\nOperation 4: swap indices \nA\n=\n[\n1\n,\n2\n,\n3\n]\nA=[1,2,3] with \nB\n=\n[\n4\n,\n5\n,\n6\n]\nB=[4,5,6].\n[0][1][1]000 becomes 000011.\nSample Input\n5\n3\n101000\n3\n101010\n3\n100100\n3\n011001\n3\n011010\nSample Output\nCase #1: 4\n1 3 5\n2 4 6\n1 2 3\n4 5 6\n1 3 4\n2 5 6\n1 2 3\n4 5 6\nCase #2: 3\n1 2 5\n3 4 6\n1 2 3\n4 5 6\n1 3 4\n2 5 6\nCase #3: 2\n1 3 5\n2 4 6\n1 2 3\n4 5 6\nCase #4: 2\n1 2 3\n4 5 6\n1 3 5\n2 4 6\nCase #5: 2\n1 2 3\n4 5 6\n1 2 5\n3 4 6",
  "test_input": "5\n3\n000111\n3\n111000\n3\n010101\n3\n000000\n4\n10101010",
  "test_output": "Case #1: 0\nCase #2: 1\n1 2 3\n4 5 6\nCase #3: -1\nCase #4: 0\nCase #5: -1\n",
  "brute_force_code": "import sys\n\ndef solve():\n    \"\"\"\n    Solves a single test case.\n    \"\"\"\n    try:\n        line = sys.stdin.readline()\n        if not line.strip():\n            line = sys.stdin.readline()\n        if not line.strip():\n            return None\n        N = int(line)\n        S = sys.stdin.readline().strip()\n    except (IOError, ValueError):\n        return None\n\n    s_list = list(S)\n    num_zeros = s_list.count('0')\n    \n    operations = []\n    \n    # A generous loop limit. For 0/1 arrays, sorting network-based\n    # approaches converge very quickly, typically in O(log N) operations.\n    # N+5 is a safe upper bound that is well within the 10N limit.\n    for _ in range(N + 5):\n        \n        # Check if the string is sorted\n        is_sorted_flag = True\n        # Check the '0' part\n        for i in range(num_zeros):\n            if s_list[i] == '1':\n                is_sorted_flag = False\n                break\n        # Check the '1' part if the '0' part was okay\n        if is_sorted_flag:\n            for i in range(num_zeros, 2 * N):\n                if s_list[i] == '0':\n                    is_sorted_flag = False\n                    break\n        \n        if is_sorted_flag:\n            break\n            \n        # Identify misplaced elements (using 1-based indexing)\n        # P: '1's that should be '0's\n        P = [i + 1 for i in range(num_zeros) if s_list[i] == '1']\n        # Q: '0's that should be '1's\n        Q = [i + 1 for i in range(num_zeros, 2 * N) if s_list[i] == '0']\n        \n        if not P:\n            # This case should be caught by the is_sorted check above,\n            # but as a safeguard.\n            break\n            \n        k = len(P)\n        \n        # The core of the strategy: construct sets A and B to swap\n        # misplaced elements.\n        \n        # For each pair of misplaced elements (one '1', one '0'),\n        # put the smaller index into a set for A and the larger for B.\n        A_core = []\n        B_core = []\n        for i in range(k):\n            p, q = P[i], Q[i]\n            if p < q:\n                A_core.append(p)\n                B_core.append(q)\n            else:\n                A_core.append(q)\n                B_core.append(p)\n\n        # Y: correctly placed elements\n        all_misplaced_indices = set(P) | set(Q)\n        Y = sorted([i + 1 for i in range(2 * N) if (i + 1) not in all_misplaced_indices])\n        \n        # We need to fill A and B to size N. We have k elements in A_core/B_core.\n        # We need to add N-k elements from Y to each.\n        num_y_to_add = N - k\n        \n        # Partition Y into two halves: smaller indices and larger indices.\n        Y_A = Y[:num_y_to_add]\n        Y_B = Y[num_y_to_add:]\n        \n        # Combine the core misplaced indices with the correctly placed ones.\n        A = sorted(A_core + Y_A)\n        B = sorted(B_core + Y_B)\n        \n        operations.append((A, B))\n        \n        # Apply the swap operation. The swaps happen simultaneously.\n        s_orig = list(s_list)\n        for i in range(N):\n            idx_a = A[i] - 1\n            idx_b = B[i] - 1\n            s_list[idx_a], s_list[idx_b] = s_orig[idx_b], s_orig[idx_a]\n\n    # Final check after the loop\n    is_sorted_final = True\n    for i in range(num_zeros):\n        if s_list[i] == '1':\n            is_sorted_final = False\n            break\n    if is_sorted_final:\n        for i in range(num_zeros, 2 * N):\n            if s_list[i] == '0':\n                is_sorted_final = False\n                break\n\n    if not is_sorted_final:\n        return \"-1\"\n    \n    output_lines = [str(len(operations))]\n    for A, B in operations:\n        output_lines.append(\" \".join(map(str, A)))\n        output_lines.append(\" \".join(map(str, B)))\n    return \"\\n\".join(output_lines)\n\ndef main():\n    try:\n        T_str = sys.stdin.readline()\n        if not T_str: return\n        T = int(T_str)\n        for i in range(1, T + 1):\n            result = solve()\n            if result is None: break\n            sys.stdout.write(f\"Case #{i}: {result}\\n\")\n    except (IOError, ValueError):\n        return\n\nif __name__ == \"__main__\":\n    main()",
  "brute_attempts": [
    {
      "number": 1,
      "code": "import sys\n\ndef solve():\n    \"\"\"\n    Solves a single test case.\n    \"\"\"\n    try:\n        line = sys.stdin.readline()\n        if not line.strip():\n            line = sys.stdin.readline()\n        if not line.strip():\n            return None\n        N = int(line)\n        S = sys.stdin.readline().strip()\n    except (IOError, ValueError):\n        return None\n\n    s_list = list(S)\n    num_zeros = s_list.count('0')\n    \n    operations = []\n    \n    # A generous loop limit. For 0/1 arrays, sorting network-based\n    # approaches converge very quickly, typically in O(log N) operations.\n    # N+5 is a safe upper bound that is well within the 10N limit.\n    for _ in range(N + 5):\n        \n        # Check if the string is sorted\n        is_sorted_flag = True\n        # Check the '0' part\n        for i in range(num_zeros):\n            if s_list[i] == '1':\n                is_sorted_flag = False\n                break\n        # Check the '1' part if the '0' part was okay\n        if is_sorted_flag:\n            for i in range(num_zeros, 2 * N):\n                if s_list[i] == '0':\n                    is_sorted_flag = False\n                    break\n        \n        if is_sorted_flag:\n            break\n            \n        # Identify misplaced elements (using 1-based indexing)\n        # P: '1's that should be '0's\n        P = [i + 1 for i in range(num_zeros) if s_list[i] == '1']\n        # Q: '0's that should be '1's\n        Q = [i + 1 for i in range(num_zeros, 2 * N) if s_list[i] == '0']\n        \n        if not P:\n            # This case should be caught by the is_sorted check above,\n            # but as a safeguard.\n            break\n            \n        k = len(P)\n        \n        # The core of the strategy: construct sets A and B to swap\n        # misplaced elements.\n        \n        # For each pair of misplaced elements (one '1', one '0'),\n        # put the smaller index into a set for A and the larger for B.\n        A_core = []\n        B_core = []\n        for i in range(k):\n            p, q = P[i], Q[i]\n            if p < q:\n                A_core.append(p)\n                B_core.append(q)\n            else:\n                A_core.append(q)\n                B_core.append(p)\n\n        # Y: correctly placed elements\n        all_misplaced_indices = set(P) | set(Q)\n        Y = sorted([i + 1 for i in range(2 * N) if (i + 1) not in all_misplaced_indices])\n        \n        # We need to fill A and B to size N. We have k elements in A_core/B_core.\n        # We need to add N-k elements from Y to each.\n        num_y_to_add = N - k\n        \n        # Partition Y into two halves: smaller indices and larger indices.\n        Y_A = Y[:num_y_to_add]\n        Y_B = Y[num_y_to_add:]\n        \n        # Combine the core misplaced indices with the correctly placed ones.\n        A = sorted(A_core + Y_A)\n        B = sorted(B_core + Y_B)\n        \n        operations.append((A, B))\n        \n        # Apply the swap operation. The swaps happen simultaneously.\n        s_orig = list(s_list)\n        for i in range(N):\n            idx_a = A[i] - 1\n            idx_b = B[i] - 1\n            s_list[idx_a], s_list[idx_b] = s_orig[idx_b], s_orig[idx_a]\n\n    # Final check after the loop\n    is_sorted_final = True\n    for i in range(num_zeros):\n        if s_list[i] == '1':\n            is_sorted_final = False\n            break\n    if is_sorted_final:\n        for i in range(num_zeros, 2 * N):\n            if s_list[i] == '0':\n                is_sorted_final = False\n                break\n\n    if not is_sorted_final:\n        return \"-1\"\n    \n    output_lines = [str(len(operations))]\n    for A, B in operations:\n        output_lines.append(\" \".join(map(str, A)))\n        output_lines.append(\" \".join(map(str, B)))\n    return \"\\n\".join(output_lines)\n\ndef main():\n    try:\n        T_str = sys.stdin.readline()\n        if not T_str: return\n        T = int(T_str)\n        for i in range(1, T + 1):\n            result = solve()\n            if result is None: break\n            sys.stdout.write(f\"Case #{i}: {result}\\n\")\n    except (IOError, ValueError):\n        return\n\nif __name__ == \"__main__\":\n    main()",
      "execution_success": true,
      "error": "",
      "execution_time": 0.038137197494506836,
      "memory_usage_mb": null,
      "has_output": true,
      "selected": true
    }
  ],
  "optimal_attempts": [
    {
      "attempt_number": 1,
      "timestamp": 1764451774.981777,
      "code": "import sys\n\ndef solve_case():\n    \"\"\"\n    Solves a single test case.\n    \"\"\"\n    try:\n        N_str = sys.stdin.readline()\n        if not N_str: return None\n        N = int(N_str)\n        S_str = sys.stdin.readline().strip()\n    except (IOError, ValueError):\n        return None\n\n    S = list(S_str)\n    num_zeros = S.count('0')\n    \n    operations = []\n\n    # The number of operations is bounded. 10N is a generous limit.\n    # A smaller, safer limit like 2*N is sufficient in practice.\n    for _ in range(10 * N + 1):\n        \n        # Check if sorted\n        is_sorted = True\n        for i in range(num_zeros):\n            if S[i] == '1':\n                is_sorted = False\n                break\n        if is_sorted:\n            for i in range(num_zeros, 2 * N):\n                if S[i] == '0':\n                    is_sorted = False\n                    break\n        \n        if is_sorted:\n            break\n\n        # Find misplaced elements\n        P = []  # Misplaced '1's (1-indexed)\n        for i in range(num_zeros):\n            if S[i] == '1':\n                P.append(i + 1)\n\n        Q = []  # Misplaced '0's (1-indexed)\n        for i in range(num_zeros, 2 * N):\n            if S[i] == '0':\n                Q.append(i + 1)\n        \n        if not P:\n            break\n\n        k = len(P)\n        \n        A_core = []\n        B_core = []\n        \n        # Pair up misplaced 1s and 0s\n        for i in range(k):\n            p_idx = P[i]\n            q_idx = Q[i]\n            A_core.append(min(p_idx, q_idx))\n            B_core.append(max(p_idx, q_idx))\n\n        # Find correctly placed indices\n        P_set = set(P)\n        Q_set = set(Q)\n        Y = []\n        for i in range(1, 2 * N + 1):\n            if i not in P_set and i not in Q_set:\n                Y.append(i)\n        \n        # Partition Y and add to A and B sets\n        num_y_slots = N - k\n        Y_A = Y[:num_y_slots]\n        Y_B = Y[num_y_slots:]\n\n        A = sorted(A_core + Y_A)\n        B = sorted(B_core + Y_B)\n        \n        operations.append((A, B))\n\n        # Apply the parallel swap operation\n        S_old = S[:]\n        for i in range(N):\n            idx_a = A[i] - 1\n            idx_b = B[i] - 1\n            S[idx_a] = S_old[idx_b]\n            S[idx_b] = S_old[idx_a]\n\n    # Final check if sorted\n    is_final_sorted = True\n    for i in range(num_zeros):\n        if S[i] == '1':\n            is_final_sorted = False\n            break\n    if is_final_sorted:\n        for i in range(num_zeros, 2 * N):\n            if S[i] == '0':\n                is_final_sorted = False\n                break\n\n    if not is_final_sorted:\n        return \"-1\"\n\n    output = [str(len(operations))]\n    for A, B in operations:\n        output.append(\" \".join(map(str, A)))\n        output.append(\" \".join(map(str, B)))\n    return \"\\n\".join(output)\n\n\ndef main():\n    \"\"\"\n    Main function to handle multiple test cases.\n    \"\"\"\n    try:\n        T_str = sys.stdin.readline()\n        if not T_str: return\n        T = int(T_str)\n        for i in range(1, T + 1):\n            result = solve_case()\n            if result is None: break\n            sys.stdout.write(f\"Case #{i}: {result}\\n\")\n    except (IOError, ValueError):\n        return\n\nif __name__ == \"__main__\":\n    main()",
      "verdict": "Accepted",
      "error_message": null,
      "execution_success": true,
      "output_match": true,
      "output_diff": null,
      "execution_time": 0.05506300926208496,
      "memory_usage_mb": null,
      "stack_trace": null
    }
  ],
  "success": true,
  "total_attempts": 1
}